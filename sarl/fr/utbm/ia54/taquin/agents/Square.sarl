package fr.utbm.ia54.taquin.agents

import fr.utbm.ia54.taquin.SharedValues
import fr.utbm.ia54.taquin.capacities.capMatrixManager
import fr.utbm.ia54.taquin.capacities.matrixManager
import fr.utbm.ia54.taquin.events.AskMySquareNumber
import fr.utbm.ia54.taquin.events.AskSquareToSearchBlankTile
import fr.utbm.ia54.taquin.events.AskSquareToSearchToAttack
import fr.utbm.ia54.taquin.events.AskYourTileToExchangeWithThatSpace
import fr.utbm.ia54.taquin.events.ExchangeWithThatSpace
import fr.utbm.ia54.taquin.events.NewGame
import fr.utbm.ia54.taquin.events.SearchSquareWithBlankTile
import fr.utbm.ia54.taquin.events.SendMySquareNumber
import fr.utbm.ia54.taquin.events.SquareWithTileToMove
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.util.OpenEventSpace
import io.sarl.util.Scopes
import java.util.ArrayList
import io.sarl.lang.core.Address
import java.util.EventListener
import java.util.UUID
import com.hazelcast.concurrent.countdownlatch.LatchKey
import io.sarl.lang.core.Space
import fr.utbm.ia54.taquin.events.CallBackLastSquaresThatEmit

agent Square { 
	uses Lifecycle, Schedules, DefaultContextInteractions, ExternalContextAccess, Behaviors, capMatrixManager
	var placementNumber : Integer 
	var tileNumberOneMe : Integer
	var puzzleSize : Integer
	var tileSquareSpace : OpenEventSpace // openEvent => tile may be register or unregister from that space
	var squareSpace = new ArrayList<OpenEventSpace>() // that eventspace will ne	ver change
	var mainSpace :  OpenEventSpace //this Square is centered in this space 
	
	def computeCost(x : Integer, y : Integer, squareSearched : Integer) : ArrayList<Integer>
	{  
		var tile : Integer
		var costToReachHisCase : Integer
		var costToReachSearchedSquare : Integer
		var costToReachBlankTile : Integer
						 
		if (y < puzzleSize)
		{
			tile = SharedValues.getMatrix(x, y) 
			
			var tileXY = new ArrayList<Integer>() 	 					
			tileXY =  getMatrixXYwithCaseNumber(tile, puzzleSize )	
			 
			var tileXYSearchedSquare = new ArrayList<Integer>()			
			tileXYSearchedSquare =  getMatrixXYwithCaseNumber(squareSearched, puzzleSize )	
			
			var xyBlankTile = new ArrayList<Integer>()
			xyBlankTile = getMatrixXYwithTileNumber(-1, puzzleSize)							
            
            costToReachSearchedSquare = Math.abs(tileXYSearchedSquare.get(0) - x) + Math.abs(tileXYSearchedSquare.get(1) - y )
            
            if(tile != -1)
            {
           		costToReachBlankTile = Math.abs(xyBlankTile.get(0) - x) + Math.abs(xyBlankTile.get(1) - y )
           		costToReachHisCase = Math.abs(tileXY.get(0) - x) + Math.abs(tileXY.get(1) - y)
            }
            else
            {
            	costToReachBlankTile = 0
            	costToReachHisCase = 0
            }            
		}
		
		var returnList = new ArrayList<Integer>()		
		returnList.add(costToReachHisCase)
		returnList.add(costToReachSearchedSquare)
		returnList.add(costToReachBlankTile)
		
		return returnList
	}
	
	on Initialize { 
		setSkill(capMatrixManager, new matrixManager)		
		puzzleSize = 4
		placementNumber = occurrence.parameters.get(0) as Integer
		tileNumberOneMe = occurrence.parameters.get(1) as Integer
		tileSquareSpace = occurrence.parameters.get(2) as OpenEventSpace 
		squareSpace = new ArrayList<OpenEventSpace>(occurrence.parameters.get(3) as ArrayList<OpenEventSpace>)
		mainSpace = occurrence.parameters.get(4) as OpenEventSpace
		
		for ( spce : squareSpace)
		{
			spce.register(asEventListener())
		}
		
		mainSpace.register(asEventListener())
		
		tileSquareSpace.register(asEventListener())		
	
	}
	
	on AskMySquareNumber  
	{
    	var evt = new SendMySquareNumber(placementNumber)
		evt.source = tileSquareSpace.getAddress(getID())
		tileSquareSpace.emit(evt)
	}
	
	on AskSquareToSearchToAttack 
	{
		println (occurrence.lastTileAttacked)
		println (tileNumberOneMe)
		
		var topTile : Integer;
		var rightTile : Integer;
		var bottomTile : Integer;
		var leftTile : Integer;

		//initiate with puzzleSize^2 number 
		//	=>useful if current tile have 3 or less neighbor 
		var topTileCostToReachHisCase : Integer = puzzleSize*puzzleSize
		var botTileCostToReachHisCase : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachHisCase : Integer =puzzleSize*puzzleSize
		var rightTileCostToReachHisCase : Integer=puzzleSize*puzzleSize
		
		var topTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var botTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var rightTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		
		var topTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var botTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var rightTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		
		var xyBlankTile = new ArrayList<Integer>()
		xyBlankTile = getMatrixXYwithTileNumber(-1, puzzleSize)
		 
		var tileXYSearchedSquare = new ArrayList<Integer>()
		tileXYSearchedSquare = getMatrixXYwithCaseNumber(occurrence.squareSearched, puzzleSize)
		
		var topTileCost = new ArrayList<Integer>()
		var botTileCost = new ArrayList<Integer>()
		var leftTileCost = new ArrayList<Integer>()
		var rightTileCost = new ArrayList<Integer>()
		
		for (var y = 0 ; y < puzzleSize ; y++)
		{ 
			for (var x = 0 ; x < puzzleSize ; x++)
			{								
				
				//we found the number in the matrix
				if (tileNumberOneMe == SharedValues.getMatrix(x, y)) 
				{ 					
					/*--get the adjacent numbers cost cheking the matrix--*/					
					
					//get top tile 
					if (y-1 >= 0 ) 
					{
						topTileCost = computeCost(x, y-1, occurrence.squareSearched)

						topTileCostToReachHisCase = topTileCost.get(0)						
						topTileCostToReachSearchedSquare = topTileCost.get(1)
						topTileCostToReachBlankTile = topTileCost.get(2)
						
						topTile =  SharedValues.getMatrix(x, y-1)						 				
					}
					
					//get bottom tile
					if (y+1 < puzzleSize)
					{
						botTileCost = computeCost(x, y+1, occurrence.squareSearched)
						
						botTileCostToReachHisCase = botTileCost.get(0)						
						botTileCostToReachSearchedSquare = botTileCost.get(1)
						botTileCostToReachBlankTile = botTileCost.get(2)
						
						bottomTile =  SharedValues.getMatrix(x, y+1)
					}
					
					//get left tile
					if(x-1 >=0 ) 
					{
						leftTileCost = computeCost(x-1, y, occurrence.squareSearched)
						
						leftTileCostToReachHisCase = leftTileCost.get(0)						
						leftTileCostToReachSearchedSquare = leftTileCost.get(1)
						leftTileCostToReachBlankTile = leftTileCost.get(2)
						
						leftTile =  SharedValues.getMatrix(x-1, y)						
					}
					
					//get right tile 
					if(x+1 < puzzleSize )
					{
						rightTileCost = computeCost(x + 1, y, occurrence.squareSearched)

						rightTileCostToReachHisCase = rightTileCost.get(0)						
						rightTileCostToReachSearchedSquare = rightTileCost.get(1)
						rightTileCostToReachBlankTile = rightTileCost.get(2)
						
						rightTile =  SharedValues.getMatrix(x+1, y)												
					}												
				}
			}
		}
		
		var tileToAttack : Integer
		
		var topTileWeighting : Integer = 0
		var botTileWeighting : Integer = 0
		var leftTileWeighting : Integer = 0
		var rightTileWeighting : Integer = 0
		
		/*SearchedSquare is prioritary 
		 * Weighting => 3
		 */
		if (rightTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare 
			&& rightTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&& rightTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare)
		{
			rightTileWeighting = rightTileWeighting + 3
		}
		
		if (botTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare
			&& botTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&&  botTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			botTileWeighting = botTileWeighting + 3
		}
		
		if (topTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare
			&& topTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare
			&&  topTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			topTileWeighting = topTileWeighting + 3			
		}
		
		if (leftTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&& topTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare
			&& leftTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			leftTileWeighting = leftTileWeighting + 3
		}
		
		/*Search blank tile is 2d prioritary 
		 * Weighting => 2
		 */
		if (rightTileCostToReachBlankTile <= leftTileCostToReachBlankTile 
			&& rightTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&& rightTileCostToReachBlankTile <= botTileCostToReachBlankTile)
		{
			rightTileWeighting = rightTileWeighting + 4
		}
		
		if (botTileCostToReachBlankTile <= leftTileCostToReachBlankTile
			&& botTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&&  botTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			botTileWeighting = botTileWeighting + 4
		}
		
		if (topTileCostToReachBlankTile <= leftTileCostToReachBlankTile
			&& topTileCostToReachBlankTile <= botTileCostToReachBlankTile
			&&  topTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			topTileWeighting = topTileWeighting + 4	
		}
		
		if (leftTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&& leftTileCostToReachBlankTile <= botTileCostToReachBlankTile
			&& leftTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			leftTileWeighting = leftTileWeighting + 4
		}
		
		
		/*Search blank tile is 3th prioritary 
		 * Weighting => 1
		 */
		if (rightTileCostToReachHisCase <= leftTileCostToReachHisCase 
			&& rightTileCostToReachHisCase <= topTileCostToReachHisCase
			&& rightTileCostToReachHisCase <= botTileCostToReachHisCase)
		{
			rightTileWeighting = rightTileWeighting + 1
		}
		
		if (botTileCostToReachHisCase <= leftTileCostToReachHisCase
			&& botTileCostToReachHisCase <= topTileCostToReachBlankTile
			&&  botTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			botTileWeighting = botTileWeighting + 1
		}
		
		if (topTileCostToReachHisCase <= leftTileCostToReachHisCase
			&& topTileCostToReachHisCase <= botTileCostToReachHisCase
			&&  topTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			topTileWeighting = topTileWeighting + 1			
		}
		
		if (leftTileCostToReachHisCase <= topTileCostToReachHisCase
			&& leftTileCostToReachHisCase <= botTileCostToReachHisCase
			&& leftTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			leftTileWeighting = leftTileWeighting + 1
		}
		
		/*
		 * Check that we are not in an infinite loop
		 */
		if (occurrence.lastTileAttacked.contains(rightTile))
		{
			rightTileWeighting = 0
		}
		
		if (occurrence.lastTileAttacked.contains(leftTile))
		{
			leftTileWeighting = 0
		}
		
		if (occurrence.lastTileAttacked.contains(bottomTile))
		{
			botTileWeighting = 0
		}
		
		if (occurrence.lastTileAttacked.contains(topTile))
		{
			topTileWeighting = 0
		}
		
		
		/*
		 * attack the tile with the less cost
		 */
		if (rightTileWeighting >= leftTileWeighting 
			&& rightTileWeighting >= topTileWeighting
			&& rightTileWeighting >= botTileWeighting)
		{
			tileToAttack = rightTile
		}
		
		if (botTileWeighting >= leftTileWeighting
			&& botTileWeighting >= topTileWeighting
			&&  botTileWeighting >= rightTileWeighting)			
		{
			tileToAttack = bottomTile	
		}
		
		if (topTileWeighting >= leftTileWeighting
			&& topTileWeighting >= botTileWeighting
			&&  topTileWeighting >= rightTileWeighting)						
		{
			tileToAttack = topTile	
		}
		
		if (leftTileWeighting >= topTileWeighting
			&& leftTileWeighting >= botTileWeighting
			&& leftTileWeighting >= rightTileWeighting)
		{
			tileToAttack = leftTile
		}
		
		println("From : "+ tileNumberOneMe+" Attack : " +tileToAttack) //debug
		var lastTilesAttacked = new ArrayList<Integer>(occurrence.lastTileAttacked)

		//todo : vÃ©rifier que tilenumberoneme n'est pas deja dans la liste
		lastTilesAttacked.add(tileNumberOneMe)
		
		var evt2 = new SearchSquareWithBlankTile(mainSpace, placementNumber, occurrence.squareSearched, tileNumberOneMe, tileToAttack, lastTilesAttacked) 
		 
		evt2.source = mainSpace.getAddress(getID())
		mainSpace.emit(evt2)		  
	}
	
	on CallBackLastSquaresThatEmit[occurrence.squareCalled == tileNumberOneMe]
	{ 
		// we call last tile and ask here to move 
		var evtMoveBack = new SearchSquareWithBlankTile(mainSpace, placementNumber, occurrence.squareSearched, tileNumberOneMe, -1, occurrence.lastTileAttacked)
		mainSpace.emit(evtMoveBack)
	}
	
	
	on SearchSquareWithBlankTile[occurrence.tileToAttack == tileNumberOneMe]
	{
//		println ("dans square " + tileNumberOneMe )
		if (occurrence.tileToAttack == -1 )
		{
			var evt = new ExchangeWithThatSpace(tileSquareSpace)
			evt.source = mainSpace.getAddress(getID())
			tileSquareSpace.emit(evt)
			
			var blankSquareXY = getMatrixXYwithTileNumber(-1, puzzleSize) 
			var blankSquare = getMatrixCaseNumberWithXY(blankSquareXY.get(0), blankSquareXY.get(1), puzzleSize) 			
			
			moveTiletoAnotherEmplacement(occurrence.squareEmplacement, -1 ,puzzleSize)			
			
			moveTiletoAnotherEmplacement(blankSquare, occurrence.tileNumberEmitter ,puzzleSize)
			printMatrix(puzzleSize)
			
			var evtMoveBlank = new AskYourTileToExchangeWithThatSpace(tileSquareSpace, placementNumber) 
			evtMoveBlank.source = mainSpace.getAddress(getID())
			tileSquareSpace.emit(evtMoveBlank, Scopes.addresses(occurrence.source))//scopes => emit to the emiter
			
			//maybe this emit don't have to be here
			var lastSquareAttacked = new ArrayList<Integer>(occurrence.tileBeforeTheLastTile)
		
			var squareToCall = lastSquareAttacked.get(lastSquareAttacked.size() - 2)
			lastSquareAttacked.remove(lastSquareAttacked.size() - 1)
			lastSquareAttacked.remove(lastSquareAttacked.size() - 1) 
			
			var evtCallBack = new CallBackLastSquaresThatEmit(squareToCall, occurrence.squareSearched, lastSquareAttacked)
			mainSpace.emit(evtCallBack)
		}
		else 
		{
			printMatrix(puzzleSize)
			println("Attack : " + occurrence.tileToAttack)
			var ad = occurrence.source
			var evt = new AskSquareToSearchToAttack(occurrence.squareSearched, occurrence.tileBeforeTheLastTile) 
			evt.source = mainSpace.getAddress(getID())

			var par = mainSpace.participants
//			mainSpace.emit(evt)
			mainSpace.emit(evt, Scopes.addresses(mainSpace.getAddress(getID())))
		}
	}
	
	// on AskSquareToSearchBlankTile 
	// {
	// 	var evt = new SearchSquareWithBlankTile(mainSpace, placementNumber, occurrence.squareSearched, tileNumberOneMe)// placementNumber is used to update the matrix
	// 	evt.source = mainSpace.getAddress(getID())
	// 	mainSpace.emit(evt)
	// }

	on AskYourTileToExchangeWithThatSpace
	{ 
		var evt = new ExchangeWithThatSpace(occurrence.newSpace)
		 
		moveTiletoAnotherEmplacement(occurrence.squareEmplacement, tileNumberOneMe, puzzleSize)
		
		evt.source = mainSpace.getAddress(getID())
		tileSquareSpace.emit(evt)
	}
	
//	on SquareWithTileToMove
//	{
//		print (occurrence.tileNumber)
//		if (occurrence.tileNumber == tileNumberOneMe)
//		{
//			var evt = new AskSquareToSearchToAttack(occurrence.squareSearched, occurrence.lastTileAttacked) 
//			evt.source = tileSquareSpace.getAddress(getID()) 
//			tileSquareSpace.emit(evt) 
//		}
//	}
//	
	on NewGame 
	{
		killMe
	}
}


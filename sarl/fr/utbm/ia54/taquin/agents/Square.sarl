package fr.utbm.ia54.taquin.agents

import fr.utbm.ia54.taquin.SharedValues
import fr.utbm.ia54.taquin.capacities.capMatrixManager
import fr.utbm.ia54.taquin.capacities.matrixManager
import fr.utbm.ia54.taquin.events.AskMySquareNumber
import fr.utbm.ia54.taquin.events.StartSearching
import fr.utbm.ia54.taquin.events.AskSquareToSearchToAttack
import fr.utbm.ia54.taquin.events.AskYourTileToExchangeWithThatSpace
import fr.utbm.ia54.taquin.events.ExchangeWithThatSpace
import fr.utbm.ia54.taquin.events.NewGame
import fr.utbm.ia54.taquin.events.SearchSquareWithBlankTile
import fr.utbm.ia54.taquin.events.SearchTileThatSearched
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.util.OpenEventSpace
import io.sarl.util.Scopes
import java.util.ArrayList
import io.sarl.lang.core.Address
import java.util.EventListener
import java.util.UUID
import com.hazelcast.concurrent.countdownlatch.LatchKey
import io.sarl.lang.core.Space
import fr.utbm.ia54.taquin.events.CallBackLastSquaresThatEmit
import fr.utbm.ia54.taquin.events.SearchSatisfaction

agent Square { 
	uses Lifecycle, Schedules, DefaultContextInteractions, ExternalContextAccess, Behaviors, capMatrixManager
	var placementNumber : Integer 
	var tileNumberOnMe : Integer
	var puzzleSize : Integer
	var tileSquareSpace : OpenEventSpace // openEvent => tile may be register or unregister from that space
	var squareSpace = new ArrayList<OpenEventSpace>() // that eventspace will ne	ver change
	var mainSpace :  OpenEventSpace //this Square is centered in this space 
	
	def computeCost(x : Integer, y : Integer, squareSearched : Integer) : ArrayList<Integer>
	{  
		var tile : Integer
		var costToReachHisCase : Integer
		var costToReachSearchedSquare : Integer
		var costToReachBlankTile : Integer
						 
		if (y < puzzleSize)
		{
			tile = SharedValues.getMatrix(x, y) 
			
			var tileXY = new ArrayList<Integer>() 	 					
			tileXY =  getMatrixXYwithCaseNumber(tile, puzzleSize )	
			 
			var tileXYSearchedSquare = new ArrayList<Integer>()			
			tileXYSearchedSquare =  getMatrixXYwithCaseNumber(squareSearched, puzzleSize )	
			
			var xyBlankTile = new ArrayList<Integer>()
			xyBlankTile = getMatrixXYwithTileNumber(-1, puzzleSize)							
            
            costToReachSearchedSquare = Math.abs(tileXYSearchedSquare.get(0) - x) + Math.abs(tileXYSearchedSquare.get(1) - y )
            
            if(tile != -1)
            {
           		costToReachBlankTile = Math.abs(xyBlankTile.get(0) - x) + Math.abs(xyBlankTile.get(1) - y )
           		costToReachHisCase = Math.abs(tileXY.get(0) - x) + Math.abs(tileXY.get(1) - y)
            }
            else
            {
            	costToReachBlankTile = 0
            	costToReachHisCase = 0
            }            
		}
		
		var returnList = new ArrayList<Integer>()		
		returnList.add(costToReachHisCase)
		returnList.add(costToReachSearchedSquare)
		returnList.add(costToReachBlankTile)
		
		return returnList
	}
	
	on Initialize { 
		setSkill(capMatrixManager, new matrixManager)		
		puzzleSize = 4
		placementNumber = occurrence.parameters.get(0) as Integer
		tileNumberOnMe = occurrence.parameters.get(1) as Integer
		tileSquareSpace = occurrence.parameters.get(2) as OpenEventSpace 
		squareSpace = new ArrayList<OpenEventSpace>(occurrence.parameters.get(3) as ArrayList<OpenEventSpace>)
		mainSpace = occurrence.parameters.get(4) as OpenEventSpace
		
		println("Square number : " + placementNumber + " Space : " + tileSquareSpace )
		
		for ( spce : squareSpace)
		{
			spce.register(asEventListener())
		}
		
		mainSpace.register(asEventListener())
		
		tileSquareSpace.register(asEventListener())		
	
	}
	
	on AskMySquareNumber  
	{
    	var evt = new StartSearching(placementNumber)
		evt.source = tileSquareSpace.getAddress(getID())
		tileSquareSpace.emit(evt)
	}
	
	on AskSquareToSearchToAttack
	{
		println (occurrence.lastTileAttacked)
		println (tileNumberOnMe)
		
		var lastAttack : Integer
		
		var topTile : Integer;
		var rightTile : Integer;
		var bottomTile : Integer;
		var leftTile : Integer;

		//initiate with puzzleSize^2 number 
		//	=>useful if current tile have 3 or less neighbor 
		var topTileCostToReachHisCase : Integer = puzzleSize*puzzleSize
		var botTileCostToReachHisCase : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachHisCase : Integer =puzzleSize*puzzleSize
		var rightTileCostToReachHisCase : Integer=puzzleSize*puzzleSize
		
		var topTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var botTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var rightTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		
		var topTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var botTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var rightTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		
		var xyBlankTile = new ArrayList<Integer>()
		xyBlankTile = getMatrixXYwithTileNumber(-1, puzzleSize)
		 
		var tileXYSearchedSquare = new ArrayList<Integer>()
		tileXYSearchedSquare = getMatrixXYwithCaseNumber(occurrence.squareSearched, puzzleSize)
		
		var topTileCost = new ArrayList<Integer>()
		var botTileCost = new ArrayList<Integer>()
		var leftTileCost = new ArrayList<Integer>()
		var rightTileCost = new ArrayList<Integer>()
		
		for (var y = 0 ; y < puzzleSize ; y++)
		{ 
			for (var x = 0 ; x < puzzleSize ; x++)
			{								
				
				//we found the number in the matrix
				if (tileNumberOnMe == SharedValues.getMatrix(x, y)) 
				{ 					
					/*--get the adjacent numbers cost cheking the matrix--*/					
					
					//get top tile  
					if (y-1 >= 0 ) 
					{
						topTileCost = computeCost(x, y-1, occurrence.squareSearched)

						topTileCostToReachHisCase = topTileCost.get(0)						
						topTileCostToReachSearchedSquare = topTileCost.get(1)
						topTileCostToReachBlankTile = topTileCost.get(2)
						
						topTile =  SharedValues.getMatrix(x, y-1)						 				
					}
					
					//get bottom tile
					if (y+1 < puzzleSize)
					{
						botTileCost = computeCost(x, y+1, occurrence.squareSearched)
						
						botTileCostToReachHisCase = botTileCost.get(0)						
						botTileCostToReachSearchedSquare = botTileCost.get(1)
						botTileCostToReachBlankTile = botTileCost.get(2)
						
						bottomTile =  SharedValues.getMatrix(x, y+1)
					}
					
					//get left tile
					if(x-1 >=0 ) 
					{
						leftTileCost = computeCost(x-1, y, occurrence.squareSearched)
						
						leftTileCostToReachHisCase = leftTileCost.get(0)						
						leftTileCostToReachSearchedSquare = leftTileCost.get(1)
						leftTileCostToReachBlankTile = leftTileCost.get(2)
						
						leftTile =  SharedValues.getMatrix(x-1, y)						
					}
					
					//get right tile 
					if(x+1 < puzzleSize )
					{
						rightTileCost = computeCost(x + 1, y, occurrence.squareSearched)

						rightTileCostToReachHisCase = rightTileCost.get(0)						
						rightTileCostToReachSearchedSquare = rightTileCost.get(1)
						rightTileCostToReachBlankTile = rightTileCost.get(2)
						
						rightTile =  SharedValues.getMatrix(x+1, y)												
					}												
				}
			}
		}
		
		var tileToAttack : Integer
		
		var topTileWeighting : Integer = 0
		var botTileWeighting : Integer = 0
		var leftTileWeighting : Integer = 0
		var rightTileWeighting : Integer = 0
		
		/*SearchedSquare is prioritary 
		 * Weighting => 3
		 */
		if (rightTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare 
			&& rightTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&& rightTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare)
		{
			rightTileWeighting = rightTileWeighting + 3
		}
		
		if (botTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare
			&& botTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&&  botTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			botTileWeighting = botTileWeighting + 3
		}
		
		if (topTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare
			&& topTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare
			&&  topTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			topTileWeighting = topTileWeighting + 3			
		}
		
		if (leftTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&& leftTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare
			&& leftTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			leftTileWeighting = leftTileWeighting + 3
		}
		
		/*Search blank tile is 2d prioritary 
		 * Weighting => 2
		 */
		if (rightTileCostToReachBlankTile <= leftTileCostToReachBlankTile 
			&& rightTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&& rightTileCostToReachBlankTile <= botTileCostToReachBlankTile)
		{
			rightTileWeighting = rightTileWeighting + 4
		}
		
		if (botTileCostToReachBlankTile <= leftTileCostToReachBlankTile
			&& botTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&&  botTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			botTileWeighting = botTileWeighting + 4
		}
		
		if (topTileCostToReachBlankTile <= leftTileCostToReachBlankTile
			&& topTileCostToReachBlankTile <= botTileCostToReachBlankTile
			&&  topTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			topTileWeighting = topTileWeighting + 4	
		}
		
		if (leftTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&& leftTileCostToReachBlankTile <= botTileCostToReachBlankTile
			&& leftTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			leftTileWeighting = leftTileWeighting + 4
		}
		
		
		/*Search blank tile is 3th prioritary 
		 * Weighting => 1
		 */
		if (rightTileCostToReachHisCase <= leftTileCostToReachHisCase 
			&& rightTileCostToReachHisCase <= topTileCostToReachHisCase
			&& rightTileCostToReachHisCase <= botTileCostToReachHisCase)
		{
			rightTileWeighting = rightTileWeighting + 1
		}
		
		if (botTileCostToReachHisCase <= leftTileCostToReachHisCase
			&& botTileCostToReachHisCase <= topTileCostToReachBlankTile
			&&  botTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			botTileWeighting = botTileWeighting + 1
		}
		
		if (topTileCostToReachHisCase <= leftTileCostToReachHisCase
			&& topTileCostToReachHisCase <= botTileCostToReachHisCase
			&&  topTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			topTileWeighting = topTileWeighting + 1			
		}
		
		if (leftTileCostToReachHisCase <= topTileCostToReachHisCase
			&& leftTileCostToReachHisCase <= botTileCostToReachHisCase
			&& leftTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			leftTileWeighting = leftTileWeighting + 1
		}
		
		/*
		 * Check that we are not in an infinite loop
		 */
		if (occurrence.lastTileAttacked.contains(rightTile))
		{
			rightTileWeighting = 0
		}
		
		if (occurrence.lastTileAttacked.contains(leftTile))
		{
			leftTileWeighting = 0
		}
		
		if (occurrence.lastTileAttacked.contains(bottomTile))
		{
			botTileWeighting = 0
		}
		
		if (occurrence.lastTileAttacked.contains(topTile))
		{
			topTileWeighting = 0
		}
		
		
		if (topTile != null)
		{
			if (occurrence.newSearch && topTile == -1)
			{
				topTileWeighting = 0
			}	
		}
		
		if (leftTile != null)
		{
			if (occurrence.newSearch && leftTile == -1)
			{
				leftTileWeighting = 0
			}	
		}
		
		if (bottomTile != null)
		{
			if (occurrence.newSearch && bottomTile == -1)
			{
				botTileWeighting = 0
			}
		}	
		
		if (rightTile != null)
		{
			if (occurrence.newSearch && rightTile == -1)
			{
				rightTileWeighting = 0
			}
		}	
	
		
	
		
		/*
		 * attack the tile with the most important weight
		 */
		if (rightTileWeighting >= leftTileWeighting 
			&& rightTileWeighting >= topTileWeighting
			&& rightTileWeighting >= botTileWeighting)
		{
			tileToAttack = rightTile
		}
		
		if (botTileWeighting >= leftTileWeighting
			&& botTileWeighting >= topTileWeighting
			&&  botTileWeighting >= rightTileWeighting)			
		{
			tileToAttack = bottomTile
		}
		
		if (topTileWeighting >= leftTileWeighting
			&& topTileWeighting >= botTileWeighting
			&&  topTileWeighting >= rightTileWeighting)						
		{
			tileToAttack = topTile	
		}
		
		if (leftTileWeighting >= topTileWeighting
			&& leftTileWeighting >= botTileWeighting
			&& leftTileWeighting >= rightTileWeighting)
		{
			tileToAttack = leftTile
		}
		
		lastAttack = tileToAttack
		
		println("From : "+ tileNumberOnMe+" Attack : " +tileToAttack) //debug
		var lastTilesAttacked = new ArrayList<Integer>(occurrence.lastTileAttacked)

		//TODO : vérifier que tileNumberOnMe n'est pas deja dans la liste
		if (!lastTilesAttacked.contains(tileNumberOnMe))
		{ 
			lastTilesAttacked.add(tileNumberOnMe)			
		}		
		
		var evt2 = new SearchSquareWithBlankTile(tileSquareSpace, placementNumber, occurrence.squareSearched, tileNumberOnMe, tileToAttack, lastTilesAttacked) 
		 
		evt2.source = mainSpace.getAddress(getID())
		mainSpace.emit(evt2)
	}
	
	on CallBackLastSquaresThatEmit[occurrence.squareCalled == tileNumberOnMe]
	{
		// we call last tile and ask here to move 
		var evtMoveBack = new SearchSquareWithBlankTile(mainSpace, placementNumber, occurrence.squareSearched, tileNumberOnMe, -1, occurrence.lastTileAttacked)
		evtMoveBack.source = mainSpace.getAddress(getID())
		mainSpace.emit(evtMoveBack)
	}
	
	
	on SearchSquareWithBlankTile[occurrence.tileToAttack == tileNumberOnMe]
	{
//		println ("dans square " + tileNumberOnMe )
		if (occurrence.tileToAttack == -1 && occurrence.tileBeforeTheLastTile.size >= 1)
		{
			/* Send an event to the tile to ask here to unregister 
			 * the current space and register with the ended square
			 */
			var evt = new ExchangeWithThatSpace(occurrence.squareSpace)
			evt.source = tileSquareSpace.getAddress(getID())
			tileSquareSpace.emit(evt)
			
			/*
			 * TileNumberOnMe is now the last tile attacked
			 */
			 var tileBeforeAttack = occurrence.tileBeforeTheLastTile
			 tileNumberOnMe = tileBeforeAttack.get(tileBeforeAttack.size() - 1)
//			
			var blankSquareXY = getMatrixXYwithTileNumber(-1, puzzleSize) 
			var blankSquare = getMatrixCaseNumberWithXY(blankSquareXY.get(0), blankSquareXY.get(1), puzzleSize)	
			
			moveTiletoAnotherEmplacement(occurrence.squareEmplacement, -1 ,puzzleSize)
			moveTiletoAnotherEmplacement(blankSquare, occurrence.tileNumberEmitter ,puzzleSize)
			printMatrix(puzzleSize)
			
			//unregister the blank tile from the current tilesquare space and register it with new tilesquare space
			
			//send an event to the emiter with the new space (the receiver of this event unregister his tile and register the blank tile)
			
			//the emiter send the space to the emiter (this square) with the new space to register the tile
			
			var evtMoveBlank = new AskYourTileToExchangeWithThatSpace(tileSquareSpace, placementNumber, occurrence.squareSearched, occurrence.tileBeforeTheLastTile) 
			evtMoveBlank.source = mainSpace.getAddress(getID())
			mainSpace.emit(evtMoveBlank, Scopes.addresses(occurrence.source))//scopes => emit to the emiter
			
			//maybe this emit don't have to be here
		}
		else 
		{
			printMatrix(puzzleSize)
			println("Attack : " + occurrence.tileToAttack)
			var ad = occurrence.source
			var evt = new AskSquareToSearchToAttack(occurrence.squareSearched, occurrence.tileBeforeTheLastTile, false)
			evt.source = mainSpace.getAddress(getID())

			var par = mainSpace.participants
//			mainSpace.emit(evt)
			mainSpace.emit(evt, Scopes.addresses(mainSpace.getAddress(getID())))
		}
	}
	
	// on AskSquareToSearchBlankTile 
	// {
	// 	var evt = new SearchSquareWithBlankTile(mainSpace, placementNumber, occurrence.squareSearched, tileNumberOnMe)// placementNumber is used to update the matrix
	// 	evt.source = mainSpace.getAddress(getID())
	// 	mainSpace.emit(evt)
	// }

	on AskYourTileToExchangeWithThatSpace
	{ 
		var evt = new ExchangeWithThatSpace(occurrence.newSpace)
		evt.source = tileSquareSpace.getAddress(getID())
		tileSquareSpace.emit(evt)
		
		tileNumberOnMe = -1
//		moveTiletoAnotherEmplacement(occurrence.squareEmplacement, tileNumberOnMe, puzzleSize)
		
		var lastSquareAttacked = new ArrayList<Integer>(occurrence.lastTileAttacked)
		
		if (lastSquareAttacked.size() > 2)
		{
			var squareToCall = lastSquareAttacked.get(lastSquareAttacked.size() - 2)
			lastSquareAttacked.remove(lastSquareAttacked.size() - 1)
//			lastSquareAttacked.remove(lastSquareAttacked.size() - 1) 
			
			var evtCallBack = new CallBackLastSquaresThatEmit(squareToCall, occurrence.squareSearched, lastSquareAttacked)
			mainSpace.emit(evtCallBack)
		}
		else
		{
			//Tile choose another tile to moove
//			var tileToAttack = new ArrayList<Integer>()
			 
			//TODO : aller chercher une liste globalele
			
			var evtSquare = new SearchTileThatSearched(3, occurrence.lastTileAttacked)
			mainSpace.emit(evtSquare) 
		
			
//			var evtSearch = new StartSearching(3) 
//			mainSpace.emit(evtSearch) 
		}
	}
	 
	 on SearchTileThatSearched[occurrence.searched == tileNumberOnMe]
	 { 
		var tileToAttack = new ArrayList<Integer>()
			 
			//TODO : aller chercher une liste globalele
			
		var evtSquare = new AskSquareToSearchToAttack(3,tileToAttack, true)
		evtSquare.source = mainSpace.getAddress(getID())
		mainSpace.emit(evtSquare, Scopes.addresses(mainSpace.getAddress(getID()))) 
		
	 } 
//	on SquareWithTileToMove
//	{
//		print (occurrence.tileNumber)
//		if (occurrence.tileNumber == tileNumberOnMe)
//		{
//			var evt = new AskSquareToSearchToAttack(occurrence.squareSearched, occurrence.lastTileAttacked) 
//			evt.source = tileSquareSpace.getAddress(getID()) 
//			tileSquareSpace.emit(evt) 
//		}
//	}
//	
	on NewGame 
	{
		killMe
	}
}


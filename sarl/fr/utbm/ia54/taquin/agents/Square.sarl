package fr.utbm.ia54.taquin.agents

import fr.utbm.ia54.taquin.SharedValues
import fr.utbm.ia54.taquin.capacities.capMatrixManager
import fr.utbm.ia54.taquin.capacities.matrixManager
import fr.utbm.ia54.taquin.events.AskMySquareNumber
import fr.utbm.ia54.taquin.events.AskSquareToSearchBlankTile
import fr.utbm.ia54.taquin.events.AskSquareToSearchToAttack
import fr.utbm.ia54.taquin.events.AskYourTileToExchangeWithThatSpace
import fr.utbm.ia54.taquin.events.ExchangeWithThatSpace
import fr.utbm.ia54.taquin.events.NewGame
import fr.utbm.ia54.taquin.events.SearchSquareWithBlankTile
import fr.utbm.ia54.taquin.events.SendMySquareNumber
import fr.utbm.ia54.taquin.events.SquareWithTileToMove
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.util.OpenEventSpace
import io.sarl.util.Scopes
import java.util.ArrayList

agent Square { 
	uses Lifecycle, Schedules, DefaultContextInteractions, ExternalContextAccess, Behaviors, capMatrixManager
	var placementNumber : Integer 
	var tileNumberOneMe : Integer
	var puzzleSize : Integer
	var tileSquareSpace : OpenEventSpace // openEvent => tile may be register or unregister from that space
	var squareSpace = new ArrayList<OpenEventSpace>() // that eventspace will never change
	var mainSpace :  OpenEventSpace //this Square is centered in this space 
	
	on Initialize { 
		setSkill(capMatrixManager, new matrixManager)		
		puzzleSize = 4
		placementNumber = occurrence.parameters.get(0) as Integer
		tileNumberOneMe = occurrence.parameters.get(1) as Integer
		tileSquareSpace = occurrence.parameters.get(2) as OpenEventSpace 
		squareSpace = new ArrayList<OpenEventSpace>(occurrence.parameters.get(3) as ArrayList<OpenEventSpace>)
		mainSpace = occurrence.parameters.get(4) as OpenEventSpace
		
		for ( spce : squareSpace)
		{
			spce.register(asEventListener())			
		}
		
		mainSpace.register(asEventListener())
		
		tileSquareSpace.register(asEventListener())				
	
	}
	
	on AskMySquareNumber  
	{
    	var evt = new SendMySquareNumber(placementNumber)
		evt.source = tileSquareSpace.getAddress(getID())
		tileSquareSpace.emit(evt)
	}
	
	on AskSquareToSearchToAttack
	{
		
		var topTile : Integer;
		var rightTile : Integer;
		var bottomTile : Integer;
		var leftTile : Integer;
				
		//initiate with puzzleSize^2 number 
		//	=>useful if current tile have 3 or less neighbor 
		var topTileCostToReachHisCase : Integer = puzzleSize*puzzleSize
		var botTileCostToReachHisCase : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachHisCase : Integer =puzzleSize*puzzleSize
		var rightTileCostToReachHisCase : Integer=puzzleSize*puzzleSize
		
		var topTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var botTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		var rightTileCostToReachSearchedSquare : Integer = puzzleSize*puzzleSize
		
		var topTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var botTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var leftTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		var rightTileCostToReachBlankTile : Integer = puzzleSize*puzzleSize
		
		var xyBlankTile = new ArrayList<Integer>()
		xyBlankTile = getMatrixXYwithTileNumber(-1, puzzleSize)
		 
		var tileXYSearchedSquare = new ArrayList<Integer>()
		tileXYSearchedSquare = getMatrixXYwithCaseNumber(occurrence.squareSearched, puzzleSize)
										
		for (var y = 0 ; y < puzzleSize ; y++)
		{ 
			for (var x = 0 ; x < puzzleSize ; x++)
			{								
				
				//we found the number in the matrix
				if (tileNumberOneMe == SharedValues.getMatrix(x, y)) 
				{ 
//					var xyFinalTilePlacement = new ArrayList<Integer>()			
//					xyFinalTilePlacement = getMatrixXYwithCaseNumber(placementNumber, puzzleSize)
					
					/*--get the adjacent numbers cost cheking the matrix--*/					
					
					//get top tile 
					if (y-1 >= 0 ) 
					{
					 	topTile = SharedValues.getMatrix(x, y-1)
					 	
					 	var tileXY = new ArrayList<Integer>() 
					 	tileXY =  getMatrixXYwithCaseNumber(topTile, puzzleSize )					 						 						 										 						
                        topTileCostToReachHisCase = Math.abs(tileXY.get(0) - x) + Math.abs(tileXY.get(1)  - (y - 1))
                        
                        topTileCostToReachSearchedSquare = Math.abs(tileXYSearchedSquare.get(0) - x) + Math.abs(tileXYSearchedSquare.get(1)  - (y - 1))
                        
                        topTileCostToReachBlankTile = Math.abs(xyBlankTile.get(0) - x) + Math.abs(xyBlankTile.get(1)  - (y - 1))
						 				
					}
					
					//get bottom tile
					if (y+1 < puzzleSize)
					{
						bottomTile = SharedValues.getMatrix(x, y+1)

						var tileXY = new ArrayList<Integer>() 						
						tileXY =  getMatrixXYwithCaseNumber(bottomTile, puzzleSize )						
	                    botTileCostToReachHisCase = Math.abs(tileXY.get(0) - x) + Math.abs(tileXY.get(1) - (y + 1))
	                    
	                    botTileCostToReachSearchedSquare = Math.abs(tileXYSearchedSquare.get(0) - x) + Math.abs(tileXYSearchedSquare.get(1) - (y + 1))
	                    
	                    botTileCostToReachBlankTile = Math.abs(xyBlankTile.get(0) - x) + Math.abs(xyBlankTile.get(1) - (y + 1))
					}
					
					//get left tile
					if(x-1 >=0 )
					{
						leftTile = SharedValues.getMatrix(x-1, y)
						
						var tileXY = new ArrayList<Integer>() 						
						tileXY =  getMatrixXYwithCaseNumber(leftTile, puzzleSize )											 												
						leftTileCostToReachHisCase = Math.abs(tileXY.get(0) - (x - 1)) + Math.abs(tileXY.get(1) - y) 
						
						leftTileCostToReachSearchedSquare = Math.abs(tileXYSearchedSquare.get(0) - (x - 1)) + Math.abs(tileXYSearchedSquare.get(1) - y)
						
						leftTileCostToReachBlankTile = Math.abs(xyBlankTile.get(0) - (x - 1)) + Math.abs(xyBlankTile.get(1) - y)											 	
					}
					
					//get right tile 
					if(x+1 < puzzleSize )
					{
						rightTile = SharedValues.getMatrix(x + 1, y)

						var tileXY = new ArrayList<Integer>()					
						tileXY =  getMatrixXYwithCaseNumber(rightTile, puzzleSize )											 																		
						rightTileCostToReachHisCase = Math.abs(tileXY.get(0) - (x + 1)) + Math.abs(tileXY.get(1) - y)
						
						rightTileCostToReachSearchedSquare = Math.abs(tileXYSearchedSquare.get(0) - (x + 1)) + Math.abs(tileXYSearchedSquare.get(1) - y)
						
						rightTileCostToReachBlankTile = Math.abs(xyBlankTile.get(0) - (x + 1)) + Math.abs(xyBlankTile.get(1) - y)																		
					}												
				}
			} 
		}		
		
		var tileToAttack : Integer
		
		var topTileWeighting : Integer = 0
		var botTileWeighting : Integer = 0
		var leftTileWeighting : Integer = 0
		var rightTileWeighting : Integer = 0
		
		/*SearchedSquare is prioritary 
		 * Weighting => 3
		 */
		if (rightTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare 
			&& rightTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&& rightTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare)
		{
			rightTileWeighting = rightTileWeighting + 3
		}
		
		if (botTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare
			&& botTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&&  botTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			botTileWeighting = botTileWeighting + 3
		}
		
		if (topTileCostToReachSearchedSquare <= leftTileCostToReachSearchedSquare
			&& topTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare
			&&  topTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			topTileWeighting = topTileWeighting + 3			
		}
		
		if (leftTileCostToReachSearchedSquare <= topTileCostToReachSearchedSquare
			&& topTileCostToReachSearchedSquare <= botTileCostToReachSearchedSquare
			&& leftTileCostToReachSearchedSquare <= rightTileCostToReachSearchedSquare)
		{
			leftTileWeighting = leftTileWeighting + 3
		}
		
		/*Search blank tile is 2d prioritary 
		 * Weighting => 2
		 */
		if (rightTileCostToReachBlankTile <= leftTileCostToReachBlankTile 
			&& rightTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&& rightTileCostToReachBlankTile <= botTileCostToReachBlankTile)
		{
			rightTileWeighting = rightTileWeighting + 2
		}
		
		if (botTileCostToReachBlankTile <= leftTileCostToReachBlankTile
			&& botTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&&  botTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			botTileWeighting = botTileWeighting + 2
		}
		
		if (topTileCostToReachBlankTile <= leftTileCostToReachBlankTile
			&& topTileCostToReachBlankTile <= botTileCostToReachBlankTile
			&&  topTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			topTileWeighting = topTileWeighting + 2			
		}
		
		if (leftTileCostToReachBlankTile <= topTileCostToReachBlankTile
			&& leftTileCostToReachBlankTile <= botTileCostToReachBlankTile
			&& leftTileCostToReachBlankTile <= rightTileCostToReachBlankTile)
		{
			leftTileWeighting = leftTileWeighting + 2
		}
		
		
		/*Search blank tile is 3th prioritary 
		 * Weighting => 1
		 */
		if (rightTileCostToReachHisCase <= leftTileCostToReachHisCase 
			&& rightTileCostToReachHisCase <= topTileCostToReachHisCase
			&& rightTileCostToReachHisCase <= botTileCostToReachHisCase)
		{
			rightTileWeighting = rightTileWeighting + 1
		}
		
		if (botTileCostToReachHisCase <= leftTileCostToReachHisCase
			&& botTileCostToReachHisCase <= topTileCostToReachBlankTile
			&&  botTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			botTileWeighting = botTileWeighting + 1
		}
		
		if (topTileCostToReachHisCase <= leftTileCostToReachHisCase
			&& topTileCostToReachHisCase <= botTileCostToReachHisCase
			&&  topTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			topTileWeighting = topTileWeighting + 1			
		}
		
		if (leftTileCostToReachHisCase <= topTileCostToReachHisCase
			&& leftTileCostToReachHisCase <= botTileCostToReachHisCase
			&& leftTileCostToReachHisCase <= rightTileCostToReachHisCase)
		{
			leftTileWeighting = leftTileWeighting + 1
		}
		
		/*
		 * attack the tile with the less cost
		 */
		if (rightTileWeighting >= leftTileWeighting 
			&& rightTileWeighting >= topTileWeighting
			&& rightTileWeighting >= botTileWeighting)
		{
			tileToAttack = rightTile
		}
		
		if (botTileWeighting >= leftTileWeighting
			&& botTileWeighting >= topTileWeighting
			&&  botTileWeighting >= rightTileWeighting)
		{
			tileToAttack = bottomTile	
		}
		
		if (topTileWeighting >= leftTileWeighting
			&& topTileWeighting >= botTileWeighting
			&&  topTileWeighting >= rightTileWeighting)
		{
			tileToAttack = topTile	
		}
		
		if (leftTileWeighting >= topTileWeighting
			&& leftTileWeighting >= botTileWeighting
			&& leftTileWeighting >= rightTileWeighting)
		{
			tileToAttack = leftTile
		}
		
		println(tileToAttack) //debug
		//Brodcast an event with the tile to move in parameters
//		var evt2 = new SquareWithTileToMove(tileToAttack, occurrence.squareSearched)
		var evt2 = new SearchSquareWithBlankTile(mainSpace,placementNumber, occurrence.squareSearched, tileNumberOneMe, tileToAttack)
		
		evt2.source = mainSpace.getAddress(getID())
		mainSpace.emit(evt2)		
	}
	
	on SearchSquareWithBlankTile
	{
		if (occurrence.tileToAttack == -1) 
		{ 
			var evt = new ExchangeWithThatSpace(tileSquareSpace)
			evt.source = mainSpace.getAddress(getID())
			mainSpace.emit(evt)
			moveTiletoAnotherEmplacement(occurrence.squareEmplacement, -1 ,puzzleSize)
			moveTiletoAnotherEmplacement(placementNumber, occurrence.tileNumberEmitter ,puzzleSize)	
			printMatrix(puzzleSize)
			
			var evtMoveBlank = new AskYourTileToExchangeWithThatSpace(tileSquareSpace, placementNumber) 
			evtMoveBlank.source = mainSpace.getAddress(getID())
			mainSpace.emit(evtMoveBlank, Scopes.addresses(occurrence.source))//scopes => emit to the emiter
		}
		else if(occurrence.tileToAttack == tileNumberOneMe)
		{
			println("Attack : " + occurrence.tileToAttack)
			var evtMoveBlank = new AskSquareToSearchToAttack(occurrence.squareSearched) 
			evtMoveBlank.source = mainSpace.getAddress(getID())
			mainSpace.emit(evtMoveBlank)
//			mainSpace.emit(evtMoveBlank, Scopes.addresses(occurrence.source))//scopes => emit to the emiter	
		}
		println("in other ")//debug
	}
	
	// on AskSquareToSearchBlankTile 
	// {
	// 	var evt = new SearchSquareWithBlankTile(mainSpace, placementNumber, occurrence.squareSearched, tileNumberOneMe)// placementNumber is used to update the matrix
	// 	evt.source = mainSpace.getAddress(getID())
	// 	mainSpace.emit(evt)
	// }

	on AskYourTileToExchangeWithThatSpace
	{ 
		var evt = new ExchangeWithThatSpace(occurrence.newSpace)
		 
		moveTiletoAnotherEmplacement(occurrence.squareEmplacement, tileNumberOneMe, puzzleSize)
		
		evt.source = mainSpace.getAddress(getID())
		mainSpace.emit(evt)
	}
	
	on SquareWithTileToMove
	{
		print (occurrence.tileNumber)
		if (occurrence.tileNumber == tileNumberOneMe)
		{
			var evt = new AskSquareToSearchToAttack(occurrence.squareSearched)
			evt.source = tileSquareSpace.getAddress(getID()) 
			tileSquareSpace.emit(evt) 
		}
	}
	
	on NewGame 
	{
		killMe
	}
}


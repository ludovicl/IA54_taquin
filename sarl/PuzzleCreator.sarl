package ia54.project.taquin

import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize 
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
//import ia54.project.taquin.PuzzleConstant
import io.sarl.util.OpenEventSpace
import io.sarl.util.OpenEventSpaceSpecification 
import java.util.Random
import java.util.Collection
import io.sarl.lang.util.SynchronizedSet
import java.util.UUID
import io.sarl.lang.core.Space
import java.util.List
import java.util.ArrayList
import io.sarl.lang.core.EventSpace
import io.sarl.lang.core.EventSpace
import io.sarl.lang.core.EventSpaceSpecification
import io.sarl.lang.core.EventListener
import io.sarl.lang.core.Capacity
import ia54.project.taquin.SharedValues

capacity capMatrixManager
{
	def printMatrix(puzzleSize : Integer) : void
}

skill matrixManager implements capMatrixManager
{
	def printMatrix(puzzleSize : Integer) : void 
	{ 
		for (var y = 0 ; y < puzzleSize ; y++)
		{ 
			for (var x = 0 ; x < puzzleSize ; x++)
			{
				print(SharedValues.getMatrix(x,y) + "|" )
			}
			println("")
		}
	}
}
 

agent PuzzleCreator {
	uses Lifecycle, Schedules, DefaultContextInteractions, ExternalContextAccess, Behaviors, capMatrixManager
	
	var puzzleSize = 4
	var squareSpace = UUID::randomUUID 
	var tileSpace = UUID::randomUUID
	var allTileNumbers = new ArrayList<Integer>()
	var tileNumber : Integer
	var spaceSquareCenter = new ArrayList<EventSpace>()
	var rightColumn = new ArrayList<Integer>()
	var leftColumn = new ArrayList<Integer>()
	var startingSpace : OpenEventSpace 
  
	on Initialize {
		  
		setSkill(capMatrixManager, new matrixManager)
		  		  
		//create an arraylist with all tile
		for (var i = 0; i<=puzzleSize*puzzleSize - 1; i++)
		{
			allTileNumbers.add(i)  
		}
		 
		for(var i = 0; i <= (puzzleSize * puzzleSize) -1; i++) // -1 cause we start at 0
		{
			var uid = UUID::randomUUID 
			var space = defaultContext.createSpace(typeof(OpenEventSpaceSpecification),uid)
			spaceSquareCenter.add(space)
		}
	
		//4 size puzzle => left column : 4, 8
		for(var j : Integer = 1; j <= puzzleSize - 2; j++)
		{ 
			leftColumn.add(j * puzzleSize )
		}
	
		//4 size puzzle => right column : 7, 11
		for(var j : Integer = 2; j <= puzzleSize - 1; j++)
		{
			rightColumn.add(j * puzzleSize - 1)  
		}
	
		for(var i = 0; i < (puzzleSize * puzzleSize); i++) 
		{
			var spaceToAddToSquareAgent = new ArrayList<EventSpace>()
			var tuileSquareSpace : OpenEventSpace  
			tuileSquareSpace = defaultContext.createSpace(typeof(OpenEventSpaceSpecification), UUID::randomUUID ) 
							
			//in these if we create multiple space with square that are neighbour
			if(i == 0) //top left corner  
			{
				println("dans i = 0")
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + 1))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + puzzleSize))
			}
			else if(i == puzzleSize -1) //top right corner
			{
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - 1))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + puzzleSize))
			}
			else if(i == (puzzleSize * puzzleSize) - puzzleSize) //bottom left corner 
			{
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + 1))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - puzzleSize))
			}
			else if(i == (puzzleSize * puzzleSize - 1)) // bottom right corner 
			{
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - 1)) 
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - puzzleSize))				
			}
			else if(leftColumn.contains(i)) // left column
			{  
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + 1))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + puzzleSize))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - puzzleSize))
			}
			else if(rightColumn.contains(i)) //right column 
			{
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - 1))
				println("size"+puzzleSize+ " "+i)
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + puzzleSize))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - puzzleSize))
			}
			else if(i > 0 && i < puzzleSize -1 ) // top line
			{
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - 1)) 
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + 1))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + puzzleSize))
			}
			else if(i < puzzleSize * puzzleSize -1 && i > (puzzleSize * puzzleSize) - puzzleSize) // bottom line
			{
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + 1))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - puzzleSize))
			} 
			else
			{
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + 1))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - 1))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i - puzzleSize))
				spaceToAddToSquareAgent.add(spaceSquareCenter.get(i + puzzleSize))
			}
	
			//spawn of square agent
			spawn(Square, i, tuileSquareSpace, spaceToAddToSquareAgent)
	
			if (allTileNumbers.size() > 0)
			{
				val random = new Random()
				var randNumber : Integer
				
				randNumber = random.nextInt(allTileNumbers.size())
				tileNumber = allTileNumbers.get(randNumber)
				allTileNumbers.remove(tileNumber)
				
			
				
				//we start the puzzle with tile 3
				if (tileNumber == puzzleSize - 1)
				{
					startingSpace = tuileSquareSpace
					startingSpace.register(asEventListener())					
				}
				
				//spawn blank tile
				if (allTileNumbers.size() == 1)
				{
					spawn(BlankTile, tuileSquareSpace)
					
					for (var x=0; x<puzzleSize; x++)
					{
						for(var y=0; y<puzzleSize;y++)
						{
							if (y*puzzleSize+x == i)
							{
								SharedValues.setMatrix(x,y,-1)
							}
						}
					} 
					
				}
				else //spawn an active tile
				{
					spawn(ActiveTile, tileNumber, tuileSquareSpace)
					
					for (var y = 0; y<puzzleSize; y++)
					{
						for(var x=0; x<puzzleSize; x++)
						{
							if (y*puzzleSize+x == i)
							{
								SharedValues.setMatrix(x,y,tileNumber)
							}
						}
					}
				}				 
				printMatrix(puzzleSize)  
			}  
		}

		var evt = new SearchSatisfaction()
		evt.source = startingSpace.getAddress(getID()); 
		startingSpace.emit(evt) 
				
		killMe //puzzle creator die

	}

}